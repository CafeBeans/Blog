---
title: 《深入理解Java虚拟机——自动内存管理机制》笔记与心得
date: 2017-07-08 22:22:27
categories: 技术探究
tags:
- JVM
---
好像好久没有码字了，之前要么忙考试，要么忙实习，再加上拖延症发作，兜兜转转，时隔多日终于有了更新，估计近期也都是周更吧，白天实习，晚上写代码，再加上点娱乐时间，也就剩下周末有时间准备码字了。由于实习的工作中涉及到JVM的内容会比较多，之前看书就只知道点概念而已，而且一直不知道学会JVM之后能拿来干嘛，现在终于有了点初步了解——分析Java程序运行时的状态，对程序进行性能调优以及维持程序的稳定性。为了能够更好的应对实习工作，下班后抽时间稍微看了下《深入理解Java虚拟机》，并重点关注JVM的自动内存管理机制，顺便对书中内存管理相关内容做下总结。
<!-- more -->
## 自动内存管理机制
在日常的开发中，我们写Java代码的大多会将注意力集中在业务逻辑上，只要能实现功能且不出bug就谢天谢地了，几乎不用操心内存泄露和内存溢出之类的问题，因为这些东西JVM已经帮我们搞定了，但是我们能够保证大型应用系统一定不会出现内存相关问题吗？肯定不能，那么一旦出问题，不熟悉JVM的话怎么能够及时排除故障，维持业务的正常运作呢？要具备问题的分析处理能力，就得知己知彼，了解JVM的相关机制，本文主要涉及自动内存管理机制。

### Java内存模型

JVM在执行Java程序的过程中会把内存区域划分为几个数据区域，不同的区域功能特点各不相同。
![](http://dl.iteye.com/upload/picture/pic/115264/4991b17e-a8b4-3d0a-a316-4651bb23da5e.png)

- 程序计数器
我们都知道java程序在执行过程中需要先被编译为字节码，然后才可以被解释执行。程序计数器的作用可以看成是当前线程所执行字节码的行号指示器，通过它虚拟机就可以知道下一条需要执行的字节码指令是什么。在多线程环境下，由于各个线程会轮流切换占用CPU时间，因此为了让每个线程都能在切换后正确工作，就需要每个线程都带有一个独立的程序计数器。
> ps:在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。
如果线程执行的是Java方法，计数器值为正在执行的虚拟机字节码指令的地址；如果线程执行的是Native方法，计数器值为空。
此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域

- 虚拟机栈
这个内存区域表示Java方法执行的内存模型：每个方法执行过程中都会创建一个用于存储局部变量表、操作数栈、动态链接、方法出口等信息的栈帧。递归为什么这么不受待见有很大的原因是其执行效率与虚拟机栈的深度挂钩，因为每次递归调用都对应一个栈帧在虚拟机入栈出栈的过程，深度越大，开销越大，效率越低。
> 局部变量表存放了编译期已知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。在编译期，局部变量表所需内存空间已完成分配，并在运行期间不会被改变。
JVM规范中：如果请求的栈深度大于虚拟机所允许的深度会抛出StackOverflowError异常；如果虚拟机动态扩展时无法申请足够的内存会抛出OutOfMemoryError异常。

- 本地方法栈
与虚拟机栈作用相似，区别在于虚拟机栈用于JVM执行Java方法（字节码），而本地方法栈用于JVM执行Native方法。Sun HotSpot虚拟机直接将这两部分合二为一了。

- 堆
在面向对象程序设计中，对象尤为重要，因此Java内存模型中，堆内存也尤为重要，因为几乎所有的对象实例以及数组都要在堆中分配内存空间（少部分对象实例得益于JIT编译器与逃逸分析技术的发展可以在其他区域分配内存空间）。由于这部分内存是线程共享的，因此也会有令人头疼的并发线程安全问题。为了能够更好的分配内存或回收内存（分代收集），堆内存也可以根据对象实例的特点作进一步的划分，不管怎样，该区域存放的都是对象实例。
> JVM规范中：如果堆中没有内存完成实例分配，且堆内存无法动态扩展，则会抛出OutOfMemoryError异常

- 方法区
方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据，为线程共享区域。
在HotSpot虚拟机中，方法区可以看成是GC分代收集中的永久代，因此HotSpot的垃圾收集器就可以像管理堆内存一样管理这部分内存区域；而对于其他的虚拟机来说是不存在永久代的，由于JVM规范并没有限制，因此不同的虚拟机对方法区的实现可以有不同的细节。虽然该区域数据比较少被回收——“永久代”，但不意味着永不回收，该区域的内存回收目标主要是针对常量池的回收和对类型的卸载，只是触发难度大、频率低。
> 由于使用永久代实现方法区会更容易遇到内存溢出问题，官方也有逐步采用Native Memory来实现方法区的规划，在目前的JDK1.7的HotSpot中，已经将原本放在永久代的字符串常量池移出。
JVM规范中：当方法区无法满足内存分配需求时，将抛出OutOFMemoryError异常

- 运行时常量池
属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这些信息位于Class文件中），同时也支持在运行期间往池中加入新的常量（String类的intern()方法）
>JVM规范中：当常量池受方法区内存限制而无法申请足够的内存时，将抛出OutOFMemoryError异常

- 直接内存
关于内存问题，仅仅知道运行时数据区是不够的，还有一块经常用到的内存，称为直接内存（不属于JVM范畴）。当我们在设置JVM参数时，若忽略了直接内存的存在使得各个内存区域综合大于物理内存限制，也会抛出OutOFMemoryError异常

### 内存泄露与溢出
>内存泄漏是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象;内存溢出是指系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出异常的现象。因此，内存泄露可导致内存溢出。
关于更多，可移步[科普：内存泄漏与内存溢出](http://www.jianshu.com/p/e97ed5d8a403)

在清楚了运行时数据区之后，我们有必要意识到，只要空间有限，都会有几率发生内存溢出的情况。在JVM规范的描述中，运行时数据区除了程序计数器之外都有可能发生OutOfMemoryError（OOM）异常，既然抛出的都是OOM异常，那么如何判断出具体是哪一个区域发生OOM异常呢？

- 堆溢出（OutOfMemoryError）
在Java内存模型中，堆用于存储对象实例，只要对象不断被创建并且GC Roots到对象之间路径可达（避免垃圾回收），则当超出最大堆容量限制就会抛出OOM异常。容易辨认的是，当堆内存发生溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会进一步提示“Java heap space”。通常的处理思路都是通过工具分析堆转储快照，进而确定是内存泄露还是内存溢出，再进一步调整源代码（处理内存泄露）或者设置JVM参数（处理内存溢出）。

- 虚拟机栈和本地方法栈溢出（StackOverflowError或OutOfMemoryError）
在JVM虚拟机规范中，除了OOM（虚拟机在扩展栈时无法申请足够的内存空间）异常之外，还有StackOverflowError(线程请求的栈深度大于虚拟机所允许的最大深度)异常。书中作者做了一个实验，表明在单线程环境下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配时，都只抛出StackOverflowError异常。而创建多线程时，则会有可能抛出“java.lang.OutOfMemoryError:unable to create new native thread”，这个时候若不能减少线程数或者更换64位虚拟机（所限制内存容量比32位大），就只能减少最大堆（其他空间）和减少栈容量（自身空间）来换取更多线程。

- 方法区和运行时常量池溢出
方法区用于存放Class的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当运行时产生大量的类时就会溢出，抛出java.lang.OutOfMemoryError：PermGen space异常。这样的场景经常在动态生成大量Class的应用中出现，如使用CGLib字节码增强和动态语言、以及大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGI的应用等。由于永久代（方法区）很少发生垃圾回收，因此得时刻注意永久代内存使用情况。

- 本机直接内存溢出
由于本机直接内存并不属于JVM范畴，但是却也抛出OOM异常，因此当上述区域异常排除之后，可以检查是否因为本机直接内存不足而发生OOM。DirectMemory容量可以通过“-XX：MaxDirectMemorySize指定，默认与堆最大值一致”。


### 垃圾回收机制

在了解相关内存区域的溢出现象之后，就应该意识到不能一直让一些没有用的“垃圾”一直占用着紧缺的内存资源，否则经常性的内存泄漏与溢出会严重影响着应用程序的性能与稳定性。关于内存方面，C++程序员的良好习惯之一就是时刻给不再使用的对象释放内存。好在如今垃圾收集技术（简称GC）已经相当成熟，在Java中内存回收已经被JVM给自动化了，Java开发者在程序开发中不用过多的关注内存问题，但是当需要排查各种内存溢出、泄漏问题时，又或者GC成为应用系统瓶颈时，就还是得具备对JVM内存回收进行必要监控和调节的能力。为此，就应该要对JVM的垃圾回收机制有一定的了解。

#### 垃圾回收区域
对于程序计数器、虚拟机栈、本地方法栈而言，当方法结束或者线程结束的时候，内存自然也随即被释放了，所以这些内存区域并不需要垃圾回收器过多的操心，而堆由于会在程序运行过程中不断创建对象，占用空间不断增大，因此是垃圾收集器主要起作用的区域。至于方法区，偶尔也会发生垃圾回收。

##### 堆的回收
在对堆进行垃圾回收之前有一个很重要的步骤就是判断堆中对象哪些是无用对象（垃圾）：
- 引用计数法
给对象设置一个引用计数器，当每次对象被引用时计数器+1，引用失效-1，当计数器值为0则可判定该对象为垃圾。
可以认为引用计数法是一种比较简洁高效的方法，然而并不能正确处理对象间相互引用的情况

- 可达性分析法
在Java中是通过可达性分析算法来判断的（涉及到图论的相关知识），以一系列称为“GC Roots”的对象作为起点，对堆中存在引用的对象进行图的遍历（深度优先或广度优先），经过的路径称为引用链。若一个对象往GCRoots不与任何引用链相连（不可达），则视为待回收的垃圾。这样即使存在对象间相互引用的情况，只要与GCRoots不可达，则都会被正确处理。
> 在java中可作为GCRoots的对象主要有：虚拟机栈（栈帧中的本地变量表）中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中JNI（即Native方法）引用的对象。
其实不可达的对象，也是可以自救的，只要在由虚拟机自动建立的低优先级的Finalizer线程执行对象的finalize()方法时，在finalize()方法中恢复与引用链的关联即可。需要注意的是任何一个对象的finalize()方法都只会被系统自动调用一次。不过这种方法不被作者推崇，因为try-finally能够有更好的表现。

在JDK1.2之后，引用又多了几个种类，以适应“当还有剩余内存空间时暂不回收无用对象”的应用场景：
（1）强引用，如Object obj = new Object()，只要存在强引用，垃圾收集器就不会回收被引用对象
（2）软引用，此类被引用的对象，在系统将要发生内存溢出异常之前，才会被列进回收范围之中进行二次回收，JDK1.2之后的实现类为SoftReference
（3）弱引用，此类被引用的对象，无论内存是否足够都会被回收，JDK1.2之后的实现类为WeakReference
（4）虚引用，最弱的引用关系，对被引用的对象完全没有影响，只是在这个对象被回收时能够收到一个系统通知，JDK1.2之后的实现类为PhaantomReference

##### 方法区的回收
方法区的垃圾收集主要是废弃常量和无用类，其中常量池的回收与堆回收类似，只要这个常量没有被使用，必要时就会被清理。而判断一个类是否为“无用类”则条件相对苛刻，需要满足：
（1）该类所有的实例已经被回收，堆中不再存在该类实例
（2）加载该类的ClassLoader已经被回收
（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
满足条件的才可以被回收，但是对于HotSpot虚拟机，实际是否被回收还需要设置虚拟机的相关参数

> 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证该区域不会溢出

#### 垃圾收集算法
上面描述了如何判定一个对象为需要被回收的无用对象，现在介绍下常见收集算法的算法思想

##### 标记—清除算法
最基础的收集算法，分为标记与清除两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收。
这个算法的不足之处在于：
（1）效率问题，标记清除两个阶段的效率都不高
（2）空间碎片问题，标记清除后会产生大量不连续的内存碎片，可能会导致接下来程序运行过程中需要分配较大对象时由于无法找到足够大的连续内存而触发另一次垃圾收集

##### 复制算法
复制算法一定程度上提高了效率，通过将可用内存容量划分为两等份，每次使用其中之一，当空间用完时就将还存活的对象复制到另外一份中，然后把原来那份内存全部清理掉。虽然效率比标记清除算法高，但是牺牲了一半的内存空间，代价太高。不过针对空间浪费的问题，其实也是可以通过改变划分的区域比例来调整的。

##### 标记—整理算法
复制算法在对象存活率较高时就需要进行较多次数的复制操作，效率反而降低。标记-整理算法则提供了新的思路，分为标记与整理两个阶段：先标记出待回收的对象，然后让所有存活对象往一端移动，最后清理存活对象以外的内存。

##### 分代收集算法
由于堆中的对象众多，随着应用程序的运行，有些可能创建不久后就废弃掉了，而有些则一直存活着。为了提高收集效率，虚拟机采用了分代收集的思想来管理内存。根据对象的存活周期，将内存划分为新生代和老年代。在新生代中发生的垃圾收集称为MinorGC，由于新生代中的对象存活率低，因此可以采用复制算法，耗费较低复制成本就可以完成收集。在老年代发生的垃圾收集称为MajorGC/FullGC，由于对象存活率高，因此常采用“标记-清除”或“标记-整理算法”。
关于对象在不同年代的划分稍后还有叙述。

#### 垃圾收集器
垃圾收集算法只是一些垃圾回收的指导，垃圾回收的具体实现还是得看垃圾收集器。在HotSpot虚拟机中有着许多不同的垃圾收集器实现，不同的收集器对应着各自适用的场景
![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)

*上面有7中收集器，分为两块，上面为新生代收集器，下面是老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用*

##### Serial收集器
Serial收集器是最基础，最简单的单线程收集器，采取复制算法，它在进行垃圾收集时，必须暂停所有的工作线程，直到收集结束。也就意味着，只要它一工作，其他线程完全不能动，这样看来简直就是一个万恶的存在啊，只能乖乖等它完成工作才可以进行别的操作。但是它也是简单而高效的，因为没有线程交互的开销，在不需要做其他工作时候单纯拿来做垃圾收集还是不错的选择。


##### ParNew收集器
除了使用多线程进行收集之外，ParNew收集器与Serial收集器没有太多的区别，也是采取复制算法等。虽然支持多个GC线程并行工作，但是其他线程仍然需要等待GC完成，而且由于线程交互的开销使得效率并不如Serial收集器，不过当CPU非常多的时候，还是可以充分利用系统资源的。

##### Parallel Scavenge收集器
和ParNew一样，Parallel Scavenge收集器也是一个并行的多线程收集器，也采用复制算法。区别在于，Parallel Scavenge是一个“吞吐量优先”的收集器（吞吐量=运行用户代码时间/CPU总消耗时间（运行用户代码时间+垃圾收集时间）），也就是说，吞吐量高代表着高效利用CPU的时间，适合在后台运算不需要太多交互的任务。此外，Parallel Scavenge可以通过设置参数来使用GC自适应调节策略，使虚拟机根据当前系统运行状况收集性能信息并动态调整以提供最大的吞吐量，自主优化。

##### Serial Old收集器
Serial收集器的老年代版本，同样是单线程收集器，只是采取标记-整理算法

##### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”

##### CMS收集器
上述收集器，在GC运行时或多或少都会引起其他工作线程的停顿，而Concurrent Mark Sweep（CMS）收集器，则是一种以获取最短回收停顿时间为目标的收集器。由于可以减少停顿时间，提高服务的响应速度，因此CMS得到了广泛的运用。
CMS收集器采用标记-清除算法，运行过程主要分为四步：初始标记、并发标记、重新标记、并发清除。其中初始标记和重新标记仍然需要停止其他线程，不过速度快，其余耗时的过程均可并发执行，因此是一款优秀的收集器。
不过它也有缺点：对CPU资源非常敏感；无法标记并发清理阶段时产生的垃圾，直到下一次GC；由于基于标记-清除算法，会产生大量空间碎片

##### G1收集器
G1是一款面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一，目前还很少投入实际运用
它具备以下特点：
并行与并发——支持GC并行执行，而且与工作线程并发执行
分代收集——可独立工作于新生代和老年代而不需要搭配，且可以采用不同方式管理新生代与老年代对象
空间整合——基于复制算法与标记-整理算法，不会产生内存碎片
可预测的停顿——可控制停顿时间
与其他收集器不同，G1虽然保留有分代的概念，但是管理堆时是将堆划分为多个大小相等的独立区域Region，并且记录回收每一个Region的性价比，当需要回收时则回收性价比最大的Region，从而提高规定时间内的收集效率。不过这种方式存在着很大的问题就是Region间对象的相互引用，可以通过引入一个值来记录这些引用，从而避免全堆扫描。
与CMS类似，G1工作时也分为几个步骤：初始标记、并发标记、最终标记、以及筛选回收。

#### 垃圾收集小结
至此，对垃圾收集器体系有了进一步的了解，知道了垃圾收集主要发生在堆中，而且采用分代收集的思想，并了解了HotSpot虚拟机的常见垃圾收集器实现

### 堆内存的分代管理
由于绝大多数虚拟机都采用分代收集的思想来管理堆内存，那么也就意味着内存分配也要采用分代的思想以契合垃圾回收机制，那么怎样判定对象应该分配到哪一代呢？这就是自动内存管理的另一大主题——内存分配策略

![](http://images2015.cnblogs.com/blog/291780/201602/291780-20160217151816909-138481834.png)
*一般情况下，虚拟机将堆内存分为新生代、老年代，HotSpot虚拟机也将方法区归入分代的思想中，称为永久代。其中，新生代又分为Eden区和Survivor区*

#### 正常分配流程
大多数情况下，对象优先在Eden区中分配，当Eden区空间不足时，则会触发MinorGC，Eden存活对象在Survivor空间允许的情况下，则会进入Survivor区并且年龄计数器+1。此后存活的Eden对象和其中一个Survivor区对象在垃圾收集器复制算法作用下在两个Survivor区之间来回切换，并且每在一次MinorGC存活下来，年龄计数器就+1，到一定岁数之后（默认15），对象就会进入老年代。

#### 提前衰老
##### 大对象直接进入老年代
大对象是指需要大量连续内存空间的对象，例如很长的字符串以及数组。将大对象分配到新生代是很不明智的做法，首先因为该对象每存活一次，就需要耗费成本找一大串连续空间进行复制，找不到时就会触发GC；其次剩余空间容量少，也容易导致空间不足而频繁GC。因此一些虚拟机可通过设置参数来让大对象超过指定大小时直接进入老年代。

##### 动态调整
如果Survivor空间中相同年龄的所有对象加起来大小大于该空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。

#### 空间分配担保机制
考虑这样一种情况，在触发一次MinorGC后，Eden和其中一个Survivor中的对象全部存活，这时往另外一个Survivor复制的时候发生空间不足的情况怎么办呢？这时就需要老年代进行分配担保，容纳Survivor放不下的对象。当然，老年代进行空间分配担保也需要足够空间才能完成的，然而在实际完成回收之前并不能确定所需要的空间，因此可以取之前每次回收进入老年代对象的总大小平均值作为过往的经验参考来与老年代剩余空间比较，以确定是否进行FullGC。

> 在JDK6 Update24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，否则将进行FullGC。

## 小结
兜兜转转，终于写完了这篇笔记，特别感谢周志明的《深入理解Java虚拟机》一书，详尽的介绍了很多关于JVM的知识点。这篇博客也主要是对书中内容结合思考后的一些简单提炼。归结一下，个人觉得JVM的自动内存管理机制所主要解决的问题，就是程序运行时内存资源如何协调的问题。首先，JVM对内存区域进行了划分，分类存储管理类属性、对象、方法变量等资源，并通过分代的思想管理变换莫测的堆内存，实现垃圾收集器回收内存以避免内存泄露与溢出等影响着程序性能与稳定的异常。
当然通篇都只是理论，重要的还是如何根据理论利用工具进行调优实践，书中有个Eclipse调优案例，是一个很好的补充，但是这种实操型技能还是需要切身实际的操作一遍，有时间会另外写一篇调优实践，貌似对Tomcat进行调优是个不错的选择。